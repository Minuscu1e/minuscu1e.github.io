[{"section":"Blog","slug":"/blog/code-2023-10-13/","title":"避免洪水泛滥","description":"每日一题","date":"October 13, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-10/1_hu0604de6f787328674d585a551e9d092f_1072173_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-10\\/1_hu0604de6f787328674d585a551e9d092f_1072173_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-10/1_hu0604de6f787328674d585a551e9d092f_1072173_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-10\\/1_hu0604de6f787328674d585a551e9d092f_1072173_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"刷题","tags":"Leetcode","content":" 你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是 满的 ，这个湖泊会发生 洪水 。你的目标是避免任意一个湖泊发生洪水。\n思路 代码实现 "},{"section":"Blog","slug":"/blog/post-2023-10-12_1/","title":"Nginx + Http2","description":"在 Nginx 中启用 Http2 并进行一些简单的测试对比","date":"October 12, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-12/2_hu772f862ef5177b2b31476e577cdd6a41_119718_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-12\\/2_hu772f862ef5177b2b31476e577cdd6a41_119718_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-12/2_hu772f862ef5177b2b31476e577cdd6a41_119718_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-12\\/2_hu772f862ef5177b2b31476e577cdd6a41_119718_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"运维","tags":"Nginx","content":"环境准备 系统环境： Centos/Windows Nginx：1.25.1 编译 nginx Windows 在 Windows 环境下，直接下载官网编译好的版本即可。\nCentos 安装软件\nyum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel 编译 nginx\n./configure --prefix=/usr/local/nginx --with-http_v2_module --with-http_ssl_module --with-http_gzip_static_module --with-http_realip_module --with-http_stub_status_module make \u0026amp; make install 安装好的 nginx 存放在 /usr/local/nginx 目录下。\n配置 首先需要生成证书文件方便测试。\nopenssl req -new -key server.key -out server.csr openssl req -new -key server.key -out server.csr openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 修改 nginx 配置，启用 http2\nserver { listen 443 ssl http2; server_name localhost; ssl_certificate server.crt; ssl_certificate_key server.key; ssl_session_cache shared: SSL : 1 m; ssl_session_timeout 5 m; ssl_ciphers HIGH: !aNULL : !MD5; ssl_prefer_server_ciphers on; location / { root html; index index.html index . htm; } } "},{"section":"Blog","slug":"/blog/post-2023-10-11_1/","title":"MySQL InnoDB 中的锁","description":"MySQL 中锁的理论和实践","date":"October 11, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-11/2_hu40b49054604de12bf9527be9d964ecb4_1045225_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-11\\/2_hu40b49054604de12bf9527be9d964ecb4_1045225_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-11/2_hu40b49054604de12bf9527be9d964ecb4_1045225_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-11\\/2_hu40b49054604de12bf9527be9d964ecb4_1045225_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"理论","tags":"MySQL","content":" 目录 什么是锁？ InnoDB 中的锁 锁的类型 实践出真理 一致性非锁定读 什么是锁？ 锁是数据库系统区别于文件系统的一个关键特性。数据库系统使用锁是为了支持对共享资源进行并发访问、提供数据的完整性和一致性。\nInnoDB存储引擎锁的实现和Oracle数据库非常类似，提供一致性的非锁定读、行级锁支持。\nlock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。\nLOCK 对象 事务 保护 数据库内容 持续时间 整个事务过程 死锁 通过 waits-for graph、 time out 等机制进行死锁检测与处理 存在于 Lock Manager 的哈希表中 lock 信息可以通过 show engine innodb status 及 information_schema 架构下的表：innodb_trx、inndo_locks、innodb_lock_waits\nInnoDB 中的锁 锁的类型 InnoDB 实现了两种标准的行级锁：\n共享锁（S Lock）：允许事务读一行数据 排他锁（X Lock）：允许事务删除或更新一行数据 下表展示了 共享锁 和 排他锁 的兼容性 X S X 不兼容 不兼容 S 不兼容 兼容 需要特别注意的是，S和X锁都是行锁，兼容是指对同一记录（row）锁的兼容性情况\nInnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁，\n若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。例如图6-3，如果需要对页上的记录r进行上X锁，那么分别需要对数据库A、表、页上意向锁IX，最后对记录r上X锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。举例来说，在对记录r加X锁之前，已经有事务对表1进行了S表锁，那么表1上已存在S锁，之后事务需要对记录r在表1上加上IX，由于不兼容，所以该事务需要等待表锁操作的完成。\nInnoDB存储引擎支持意向锁设计比较简练，其意向锁即为表级别的锁。支持两种意向锁：\n意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁 意向锁其实不会阻塞除全表扫以外的任何请求。故表级意向锁与行级锁的兼容性如表：\nIS IX S X IS 兼容 兼容 兼容 不兼容 IX 兼容 兼容 不兼容 不兼容 S 不兼容 不兼容 兼容 不兼容 X 不兼容 不兼容 不兼容 不兼容 用户可以通过命令SHOW ENGINE INNODB STATUS来查看当前锁请求的信息。\n从InnoDB1.0开始，在INFORMATION_SCHEMA架构下添加了表INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS\nINNODB_TRX 表定义如下：\n字段名 说明 trx_id InnoDB 存储引擎内部唯一的事务ID trx_state 当前事务的状态 trx_started 事务开始的时间 trx_requested_lock_id 等待事务的锁ID，如 trx_state 的状态为 LOCK_WAIT，那么该值代表当前事务等待之前事务占用所资源的ID trx_wait_started 事务等待开始的时间 trx_weight 事务的权重，反映了一个事务修改和所著的行数。在发生死锁需要回滚时，InnoDB 存储引擎会选择该值最小的进行回滚 trx_mysql_thread_id MySQL 中的线程 ID trx_query 事务运行的SQL INNODB_LOCKS 表定义如下：\n字段名 说明 lock_id 锁的 ID lock_trx_id 事务 ID lock_mode 锁的模式 lock_type 锁的类型，表锁还是行锁 lock_table 要加锁的表 lock_index 锁住的索引 lock_space 锁对象的 space id lock_page 事务锁定页的数量，如是表锁，则该值为 null lock_rec 事务锁定行的数量，如是表锁，则该值为 null lock_data 事务锁定记录的主键数，如是表锁，则该值为 null INNODB_LOCK_WAITS 的结构：\n字段 说明 requesting_trx_id 申请锁资源的事务 ID requesting_lock_id 申请的锁的 ID blocking_trx_id 阻塞的事务 ID blocking_lock_id 阻塞的锁 ID INNODB_TRX 给出了当前执行事务的信息，INNODB_LOCKS 给出了当前锁的信息，而在 INNODB_LOCK_WAITS 给出了 **事务和锁之间相互阻塞的关系 **\n实践出真理 利用三张 innodb_trx、innodb_locks、innodb_lock_watis 三张表的信息，获取到当前阻塞的事务信息、锁信息以及 执行的 Quey。\n首先将事务的等待时间调大一些。默认的 innodb_lock_wait_timeout 值是 50，可以调整到 300 便于观察。 # my.ini [mysqld] innodb_lock_wait_timeout = 300 然后重启 MySQL\n利用 X 和 X 不兼容的特性，模拟锁竞争 先开启一个 session：A\nbegin; update sys_user set username = \u0026#39;超级管理员\u0026#39; where id = 1 在开启一个 session：B\nbegin: update sys_user set username = \u0026#39;管理员\u0026#39; where id = 1 观察三张表的数据。 innodb_trx：会有两条事务数据，其中一条的 trx_state = LOCK_WAIT，另一条的则是 RUNNING。 innodb_locks：会有两条数据，两条数据的 lock_mode = X，lock_type = RECORD(行)，lock_data = 1 innodb_lock_wait：只有一条数据，对应着事务和锁的阻塞关系。 通过一个 SQL 查询到事务、锁的相关信息 SELECT wait.requesting_trx_id as requesting_trx_id, r_trx.trx_state as request_trx_state, r_trx.trx_query as request_trx_query, wait.requested_lock_id as request_lock_id, r_lock.lock_mode as request_lock_mode, r_lock.lock_index as request_lock_index, r_lock.lock_table as request_lock_table, wait.blocking_trx_id as blocking_trx_id, b_trx.trx_state as blocking_trx_state, b_trx.trx_query as blocking_trx_query, wait.blocking_lock_id as blocking_lock_id, b_lock.lock_mode as blocking_lock_mode, b_lock.lock_index as blocking_lock_index, b_lock.lock_table as blocking_lock_table FROM information_schema.INNODB_LOCK_WAITS wait LEFT JOIN information_schema.INNODB_TRX r_trx ON wait.requesting_trx_id = r_trx.trx_id LEFT JOIN information_schema.INNODB_LOCKS r_lock ON wait.requested_lock_id = r_lock.lock_id LEFT JOIN information_schema.INNODB_TRX b_trx ON wait.blocking_trx_id = b_trx.trx_id LEFT JOIN information_schema.INNODB_LOCKS b_lock ON wait.blocking_lock_id = b_lock.lock_id 一致性非锁定读 一致性的非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎会去读取行的一个快照数据。\n快照数据是指该行的之前版本的数据，该实现是通过undo段来完成。\n"},{"section":"Blog","slug":"/blog/code-2023-10-12/","title":"旋转矩阵","description":"每日一题","date":"October 11, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-12/1_hucd9896367d3611866431f1354dfc95e1_1067680_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-12\\/1_hucd9896367d3611866431f1354dfc95e1_1067680_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-12/1_hucd9896367d3611866431f1354dfc95e1_1067680_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-12\\/1_hucd9896367d3611866431f1354dfc95e1_1067680_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"刷题","tags":"Leetcode","content":" 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？\n思路 因为是90度旋转，所以会有4个坐标的相互对应关系，只需要计算出四个坐标即可。 代码实现 class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i \u0026lt; n / 2; i++) { for (int j = 0; j \u0026lt; (n + 1) / 2; j++) { int tmp = matrix[i][j]; matrix[i][j] = matrix[n - 1 - j][i]; matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j]; matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i]; matrix[j][n - 1 - i] = tmp; } } } } "},{"section":"Blog","slug":"/blog/code-2023-10-11/","title":"一次编辑","description":"每日一题","date":"October 10, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-11/1_hudc698b348281831fc1b6db83067647d5_444283_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"236\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-11\\/1_hudc698b348281831fc1b6db83067647d5_444283_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-11/1_hudc698b348281831fc1b6db83067647d5_444283_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-11\\/1_hudc698b348281831fc1b6db83067647d5_444283_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"刷题","tags":"Leetcode","content":" 字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。\n思路 其实删除和插入在本质上是一种操作，插入是对短的字符串进行添加而删除则是对长的字符串进行移除。那么假设我们始终对长的进行操作，那么这道题中只有两种情况：删除和替换。 替换可以看做是一种在两个字符串下的特殊情况。 最后需要判断一下两个指针是否都走到末尾 代码实现 class Solution { public boolean oneEditAway(String first, String second) { if (first.length() \u0026gt; second.length()) { return oneEditAway(second, first); } int fp = 0, sp = 0; boolean hasOption = false; while (fp \u0026lt; first.length() \u0026amp;\u0026amp; sp \u0026lt; second.length()) { if (first.charAt(fp) == second.charAt(sp)) { fp++; } else { if (hasOption) { return false; } if (first.length() == second.length()) { fp++; } hasOption = true; } sp++; } return fp == first.length() \u0026amp;\u0026amp; sp == second.length() || second.length() - first.length() == 1; } } "},{"section":"Blog","slug":"/blog/code-2023-10-10/","title":"移动机器人","description":"每日一题","date":"October 9, 2023","image":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-10/1_hu0604de6f787328674d585a551e9d092f_1072173_420x0_resize_q90_h2_lanczos_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"420\"\n          height=\"280\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-10\\/1_hu0604de6f787328674d585a551e9d092f_1072173_420x0_resize_lanczos_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","imageSM":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n  \n\n  \n  \n    \n      \n    \n\n\n    \n    \n\n\n    \n    \n      \n      \n    \n    \n    \n\n\n    \n    \n      \n      \n        \n        \n        \n        \n        \n        \n          \n          \n          \n          \n        \n\n\n        \n        \n\n\n        \u003cimg\n          \n            src=\"/images/blog/2023-10-10/1_hu0604de6f787328674d585a551e9d092f_1072173_100x100_fill_q90_h2_lanczos_smart1_3.webp\" loading=\"lazy\" decoding=\"async\"\n          \n\n          alt=\"\"\n          class=\"  img\"\n          width=\"100\"\n          height=\"100\"\n          onerror=\"this.onerror='null';this.src='\\/images\\/blog\\/2023-10-10\\/1_hu0604de6f787328674d585a551e9d092f_1072173_100x100_fill_lanczos_smart1_3.png';\" /\u003e\n\n        \n      \n      \n    \n    \n  \n\n\n  \n","searchKeyword":"","categories":"刷题","tags":"Leetcode","content":" 有一些机器人分布在一条无限长的数轴上，他们初始坐标用一个下标从 0 开始的整数数组 nums 表示。当你给机器人下达命令时，它们以每秒钟一单位的速度开始移动。 给你一个字符串 s ，每个字符按顺序分别表示每个机器人移动的方向。\u0026lsquo;L\u0026rsquo; 表示机器人往左或者数轴的负方向移动，\u0026lsquo;R\u0026rsquo; 表示机器人往右或者数轴的正方向移动。 当两个机器人相撞时，它们开始沿着原本相反的方向移动。 请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。由于答案可能很大，请你将答案对 109 + 7 取余后返回。\n思路 虽然题目中提到了会存在碰撞的情况，但其实有无碰撞后的结果是一样的（机器人本身没有特殊标记），所以在计算这一部分时候只需要根据 L 和 R 的区别对初始位置进行 + - 即可。 在计算位置之前，先需要对球进行从小到大的排序，方便进行距离计算(转换到数轴计算)。 利用数学技巧：数轴的思想计算距离和值。 代码实现 class Solution { static int mod = (int) 1e9 + 7; public int sumDistance(int[] nums, String s, int d) { int n = s.length(); long[] pos = new long[n]; for (int i = 0; i \u0026lt; n; i++) pos[i] = (long) nums[i] + (s.charAt(i) == \u0026#39;R\u0026#39; ? d : -d); Arrays.sort(pos); long result = 0; for (int left = 0, right = n - 1; left \u0026lt; right; left++, right--) { result += (right - left) * (pos[right] - pos[left]); result %= mod; } return (int) result; } } "}]